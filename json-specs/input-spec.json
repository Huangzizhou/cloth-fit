[
    {
        "pointer": "/",
        "type": "object",
        "required": [
            "avatar_mesh_path",
            "garment_path",
            "source_skeleton_path",
            "target_skeleton_path",
            "fit_weight",
            "curve_center_target_weight"
        ],
        "optional": [
            "units",
            "common",
            "root_path",
            "contact",
            "solver",
            "output",
            "is_skirt",
            "voxel_size",
            "incremental_steps",
            "avatar_skin_weights_path",
            "symmetry_weight",
            "twist_penalty_weight",
            "curvature_penalty_weight",
            "similarity_penalty_weight",
            "curve_size_weight"
        ],
        "doc": "Root of the configuration file."
    },
    {
        "pointer": "/incremental_steps",
        "default": 1,
        "type": "int",
        "min": 1,
        "doc": "If this value is larger than 1, instead of directly optimizing towards the target avatar directly, the optimization is divided into a number of substeps to gradually optimize towards the target. Larger values may be useful when the target avatar is very different from the original avatar."
    },
    {
        "pointer": "/is_skirt",
        "type": "bool",
        "default": false,
        "doc": "Set this value to true if the garment is a skirt. This option will insert an extra skeleton bone in the middle of two legs, which helps to enforce the positional constraint on the hemline of the skirt."
    },
    {
        "pointer": "/voxel_size",
        "type": "float",
        "default": 0.01,
        "doc": "The voxel size of the signed distance field representing the target avatar. The avatars are scaled to unit size."
    },
    {
        "pointer": "/avatar_skin_weights_path",
        "default": "",
        "type": "file",
        "doc": "The path to the file that stores the skinning weights of the target avatar. The skinning weights should be a matrix of size #number_of_skeleton_bones times #number_of_vertices. The skinning weights will be used to project the target avatar to its skeleton. If this file is not provided, the vertices will be simply projected to the closest bone in distance."
    },
    {
        "pointer": "/avatar_mesh_path",
        "type": "file",
        "extensions": [
            ".obj"
        ],
        "doc": "The path to the target avatar mesh. The target avatar mesh should be one or multiple closed surfaces, so that it can be converted to a signed distance field by OpenVDB."
    },
    {
        "pointer": "/garment_path",
        "type": "file",
        "extensions": [
            ".obj"
        ],
        "doc": "The path to the source garment mesh. The garment mesh should be a connected manifold surface."
    },
    {
        "pointer": "/source_skeleton_path",
        "type": "file",
        "extensions": [
            ".obj"
        ],
        "doc": "The path to the skeleton mesh of the source avatar. The skeleton connectivity should be exactly the same for the source and target avatars."
    },
    {
        "pointer": "/target_skeleton_path",
        "type": "file",
        "extensions": [
            ".obj"
        ],
        "doc": "The path to the skeleton mesh of the target avatar. The skeleton connectivity should be exactly the same for the source and target avatars."
    },
    {
        "pointer": "/fit_weight",
        "type": "float",
        "min": 0,
        "doc": "The weight controlling how tight does the garment fit on the avatar."
    },
    {
        "pointer": "/curve_center_target_weight",
        "type": "float",
        "min": 0,
        "doc": "The weight of enforcing the positional constraints on curve loops, e.g. hem, collar, cuff."
    },
    {
        "pointer": "/symmetry_weight",
        "type": "float",
        "default": 0,
        "min": 0,
        "doc": "The weight of enforcing symmetry on originally symmetric garment curve loops, e.g. collar."
    },
    {
        "pointer": "/twist_penalty_weight",
        "type": "float",
        "min": 0,
        "default": 0,
        "doc": "The weight of preserving torsion on the curve loops."
    },
    {
        "pointer": "/curvature_penalty_weight",
        "type": "float",
        "min": 0,
        "default": 0,
        "doc": "The weight of preserving curvature on the curve loops."
    },
    {
        "pointer": "/similarity_penalty_weight",
        "type": "float",
        "default": 1,
        "min": 0,
        "doc": "The weight of preserving surface geometry."
    },
    {
        "pointer": "/curve_size_weight",
        "type": "float",
        "default": 0,
        "min": 0,
        "doc": "The weight of penalizing the curve loop size, for cases like the collar being much wider than the neck."
    },
    {
        "pointer": "/common",
        "default": "",
        "type": "file",
        "extensions": [
            ".json"
        ],
        "doc": "Path to common settings will patch the current file."
    },
    {
        "pointer": "/root_path",
        "default": "",
        "type": "string",
        "doc": "Path for all relative paths, set automatically to the folder containing this JSON."
    },
    {
        "pointer": "/units",
        "default": null,
        "type": "object",
        "optional": [
            "length",
            "mass",
            "time",
            "characteristic_length"
        ],
        "doc": "Basic units used in the code."
    },
    {
        "pointer": "/units/length",
        "default": "m",
        "type": "string",
        "doc": "Length unit."
    },
    {
        "pointer": "/units/mass",
        "default": "kg",
        "type": "string",
        "doc": "Mass unit."
    },
    {
        "pointer": "/units/time",
        "default": "s",
        "type": "string",
        "doc": "Time unit."
    },
    {
        "pointer": "/units/characteristic_length",
        "default": 1,
        "type": "float",
        "doc": "Characteristic length, used for tolerances."
    },
    {
        "pointer": "/tests",
        "default": null,
        "type": "object",
        "optional": [
            "err_h1",
            "err_h1_semi",
            "err_l2",
            "err_linf",
            "err_linf_grad",
            "err_lp",
            "margin",
            "time_steps"
        ],
        "doc": "Used to test to compare different norms of solutions."
    },
    {
        "pointer": "/contact",
        "default": null,
        "type": "object",
        "optional": [
            "enabled",
            "dhat",
            "dhat_percentage",
            "epsv",
            "friction_coefficient",
            "use_convergent_formulation",
            "collision_mesh",
            "periodic"
        ],
        "doc": "Contact handling parameters."
    },
    {
        "pointer": "/contact/enabled",
        "default": false,
        "type": "bool",
        "doc": "True if contact handling is enabled."
    },
    {
        "pointer": "/contact/dhat",
        "default": 0.001,
        "min": 0,
        "type": "float",
        "doc": "Contact barrier activation distance."
    },
    {
        "pointer": "/contact/dhat_percentage",
        "default": 0.8,
        "type": "float",
        "doc": "$\\hat{d}$ as percentage of the diagonal of the bounding box"
    },
    {
        "pointer": "/contact/epsv",
        "default": 0.001,
        "min": 0,
        "type": "float",
        "doc": "Friction smoothing parameter."
    },
    {
        "pointer": "/contact/friction_coefficient",
        "default": 0,
        "type": "float",
        "doc": "Coefficient of friction (global)"
    },
    {
        "pointer": "/contact/use_convergent_formulation",
        "default": false,
        "type": "bool",
        "doc": "Whether to use the convergent (area weighted) formulation of IPC."
    },
    {
        "pointer": "/contact/collision_mesh",
        "type": "object",
        "required": [
            "mesh",
            "linear_map"
        ],
        "optional": [
            "enabled"
        ],
        "default": "skip",
        "doc": "Load a preconstructed collision mesh."
    },
    {
        "pointer": "/contact/collision_mesh",
        "type": "object",
        "required": [
            "max_edge_length"
        ],
        "optional": [
            "tessellation_type",
            "enabled"
        ],
        "doc": "Construct a collision mesh with a maximum edge length."
    },
    {
        "pointer": "/contact/collision_mesh/mesh",
        "type": "string",
        "doc": "Path to preconstructed collision mesh."
    },
    {
        "pointer": "/contact/collision_mesh/linear_map",
        "type": "string",
        "doc": "HDF file storing the linear mapping of displacements."
    },
    {
        "pointer": "/contact/collision_mesh/max_edge_length",
        "type": "float",
        "doc": "Maximum edge length to use for building the collision mesh."
    },
    {
        "pointer": "/contact/collision_mesh/tessellation_type",
        "type": "string",
        "options": [
            "regular",
            "irregular"
        ],
        "default": "regular",
        "doc": "Type of tessellation to use for building the collision mesh."
    },
    {
        "pointer": "/contact/collision_mesh/enabled",
        "type": "bool",
        "default": true,
        "doc": ""
    },
    {
        "pointer": "/contact/periodic",
        "default": false,
        "type": "bool",
        "doc": "Set to true to check collision between adjacent periodic cells."
    },
    {
        "pointer": "/solver",
        "type": "include",
        "spec_file": "polysolve.json",
        "doc": "Settings for the solver."
    },
    {
        "pointer": "/solver",
        "default": null,
        "type": "object",
        "optional": [
            "max_threads",
            "linear",
            "nonlinear",
            "augmented_lagrangian",
            "contact",
            "rayleigh_damping",
            "advanced"
        ],
        "doc": "The settings for the solver including linear solver, nonlinear solver, and some advanced options."
    },
    {
        "pointer": "/solver/max_threads",
        "default": 16,
        "type": "int",
        "min": 0,
        "doc": "Maximum number of threads used; 0 is unlimited."
    },
    {
        "pointer": "/solver/augmented_lagrangian",
        "default": null,
        "type": "object",
        "optional": [
            "initial_weight",
            "scaling",
            "max_weight",
            "eta",
            "error_threshold",
            "nonlinear"
        ],
        "doc": "Parameters for the AL for imposing Dirichlet BCs. If the bc are not imposable, we add $w\\|u - bc\\|^2$ to the energy ($u$ is the solution at the Dirichlet nodes and $bc$ are the Dirichlet values). After convergence, we try to impose bc again. The algorithm computes E + a/2*AL^2 - lambda AL, where E is the current energy (elastic, inertia, contact, etc.) and AL is the augmented Lagrangian energy. a starts at `initial_weight` and, in case DBC cannot be imposed, we update a as `a *= scaling` until `max_weight`. See IPC additional material"
    },
    {
        "pointer": "/solver/augmented_lagrangian/nonlinear",
        "type": "include",
        "spec_file": "nonlinear-solver-spec.json",
        "doc": "Settings for nonlinear solver in augmented lagrangian."
    },
    {
        "pointer": "/solver/augmented_lagrangian/initial_weight",
        "default": 1e6,
        "min": 0,
        "type": "float",
        "doc": "Initial weight for AL"
    },
    {
        "pointer": "/solver/augmented_lagrangian/error",
        "default": 1e-2,
        "min": 0,
        "type": "float",
        "doc": "Don't stop AL unless the error is smaller than this number."
    },
    {
        "pointer": "/solver/augmented_lagrangian/scaling",
        "default": 2.0,
        "type": "float",
        "doc": "Multiplication factor"
    },
    {
        "pointer": "/solver/augmented_lagrangian/max_weight",
        "default": 1e8,
        "type": "float",
        "doc": "Maximum weight"
    },
    {
        "pointer": "/solver/augmented_lagrangian/eta",
        "default": 0.99,
        "min": 0,
        "max": 1,
        "type": "float",
        "doc": "Tolerance for increasing the weight or updating the lagrangian"
    },
    {
        "pointer": "/solver/augmented_lagrangian/error_threshold",
        "default": 1e-2,
        "min": 0,
        "type": "float",
        "doc": "Error tolerance for enforcing the constraints directly"
    },
    {
        "pointer": "/solver/contact",
        "default": null,
        "type": "object",
        "optional": [
            "CCD",
            "friction_iterations",
            "friction_convergence_tol",
            "barrier_stiffness"
        ],
        "doc": "Settings for contact handling in the solver."
    },
    {
        "pointer": "/solver/contact/CCD",
        "default": null,
        "type": "object",
        "optional": [
            "broad_phase",
            "tolerance",
            "max_iterations"
        ],
        "doc": "CCD options"
    },
    {
        "pointer": "/solver/contact/CCD/broad_phase",
        "default": "hash_grid",
        "type": "string",
        "options": [
            "hash_grid",
            "HG",
            "brute_force",
            "BF",
            "spatial_hash",
            "SH",
            "bvh",
            "BVH",
            "sweep_and_prune",
            "SAP",
            "sweep_and_tiniest_queue",
            "STQ"
        ],
        "doc": "Broad phase collision-detection algorithm to use"
    },
    {
        "pointer": "/solver/contact/CCD/tolerance",
        "default": 1e-06,
        "type": "float",
        "doc": "CCD tolerance"
    },
    {
        "pointer": "/solver/contact/CCD/max_iterations",
        "default": 1000000,
        "type": "int",
        "doc": "Maximum number of iterations for continuous collision detection"
    },
    {
        "pointer": "/solver/contact/friction_iterations",
        "default": 1,
        "type": "int",
        "doc": "Maximum number of update iterations for lagged friction formulation (see IPC paper)."
    },
    {
        "pointer": "/solver/contact/friction_convergence_tol",
        "default": 0.01,
        "type": "float",
        "doc": "Tolerence for friction convergence"
    },
    {
        "pointer": "/solver/contact/barrier_stiffness",
        "default": "adaptive",
        "options": [
            "adaptive"
        ],
        "type": "string",
        "doc": "How coefficient of clamped log-barrier function for contact is updated"
    },
    {
        "pointer": "/solver/contact/barrier_stiffness",
        "type": "float",
        "doc": "The coefficient of clamped log-barrier function value when not adaptive"
    },
    {
        "pointer": "/solver/rayleigh_damping",
        "type": "list",
        "default": [],
        "doc": "Apply Rayleigh damping."
    },
    {
        "pointer": "/solver/rayleigh_damping/*",
        "type": "object",
        "required": [
            "form",
            "stiffness_ratio"
        ],
        "optional": [
            "lagging_iterations"
        ],
        "doc": "Apply Rayleigh damping to the given Form with a stiffness ratio."
    },
    {
        "pointer": "/solver/rayleigh_damping/*",
        "type": "object",
        "required": [
            "form",
            "stiffness"
        ],
        "optional": [
            "lagging_iterations"
        ],
        "doc": "Apply Rayleigh damping to the given Form with a stiffness."
    },
    {
        "pointer": "/solver/rayleigh_damping/*/form",
        "type": "string",
        "options": [
            "elasticity",
            "contact",
            "friction"
        ],
        "doc": "Form to damp."
    },
    {
        "pointer": "/solver/rayleigh_damping/*/stiffness_ratio",
        "type": "float",
        "min": 0,
        "doc": "Ratio of to damp (stiffness = 0.75 * stiffness_ratio * Δt³)."
    },
    {
        "pointer": "/solver/rayleigh_damping/*/stiffness",
        "type": "float",
        "min": 0,
        "doc": "Ratio of to damp."
    },
    {
        "pointer": "/solver/rayleigh_damping/*/lagging_iterations",
        "default": 1,
        "type": "int",
        "doc": "Maximum number of update iterations for lagging."
    },
    {
        "pointer": "/solver/advanced",
        "default": null,
        "type": "object",
        "optional": [
            "cache_size",
            "lump_mass_matrix",
            "lagged_regularization_weight",
            "lagged_regularization_iterations"
        ],
        "doc": "Advanced settings for the solver"
    },
    {
        "pointer": "/solver/advanced/cache_size",
        "default": 900000,
        "type": "int",
        "doc": "Maximum number of elements when the assembly values are cached."
    },
    {
        "pointer": "/solver/advanced/lump_mass_matrix",
        "default": false,
        "type": "bool",
        "doc": "If true, use diagonal mass matrix with entries on the diagonal equal to the sum of entries in each row of the full mass matrix.}"
    },
    {
        "pointer": "/solver/advanced/lagged_regularization_weight",
        "default": 0,
        "type": "float",
        "doc": "Weight used to regularize singular static problems."
    },
    {
        "pointer": "/solver/advanced/lagged_regularization_iterations",
        "default": 1,
        "type": "int",
        "doc": "Number of regularize singular static problems."
    },
    {
        "pointer": "/output",
        "default": null,
        "type": "object",
        "optional": [
            "directory",
            "log",
            "json",
            "restart_json",
            "paraview",
            "data",
            "advanced",
            "reference"
        ],
        "doc": "output settings"
    },
    {
        "pointer": "/output/directory",
        "default": ".",
        "type": "string",
        "doc": "Directory for output files."
    },
    {
        "pointer": "/output/log",
        "spec_file": "log.json",
        "type": "include",
        "doc": "Setting for the output log."
    },
    {
        "pointer": "/output/json",
        "default": "",
        "type": "string",
        "doc": "File name for JSON output statistics on time/error/etc."
    },
    {
        "pointer": "/output/restart_json",
        "default": "",
        "type": "string",
        "doc": "File name for JSON output to restart the simulation."
    },
    {
        "pointer": "/output/paraview",
        "default": null,
        "type": "object",
        "optional": [
            "file_name",
            "vismesh_rel_area",
            "skip_frame",
            "high_order_mesh",
            "volume",
            "surface",
            "wireframe",
            "points",
            "options"
        ],
        "doc": "Output in paraview format"
    },
    {
        "pointer": "/output/paraview/file_name",
        "default": "",
        "type": "string",
        "doc": "Paraview output file name"
    },
    {
        "pointer": "/output/paraview/vismesh_rel_area",
        "default": 1e-05,
        "type": "float",
        "doc": "relative area for the upsampled visualisation mesh"
    },
    {
        "pointer": "/output/paraview/skip_frame",
        "default": 1,
        "type": "int",
        "doc": "export every skip_frame-th frames for time dependent simulations"
    },
    {
        "pointer": "/output/paraview/high_order_mesh",
        "default": true,
        "type": "bool",
        "doc": "Enables/disables high-order output for paraview. Supported only for isoparametric or linear meshes with high-order solutions."
    },
    {
        "pointer": "/output/paraview/volume",
        "default": true,
        "type": "bool",
        "doc": "Export volumetric mesh"
    },
    {
        "pointer": "/output/paraview/surface",
        "default": false,
        "type": "bool",
        "doc": "Export surface mesh (in 2d polygon)"
    },
    {
        "pointer": "/output/paraview/wireframe",
        "default": false,
        "type": "bool",
        "doc": "Export the wireframe of the mesh"
    },
    {
        "pointer": "/output/paraview/points",
        "default": false,
        "type": "bool",
        "doc": "Export the Dirichlet points"
    },
    {
        "pointer": "/output/paraview/options",
        "default": null,
        "type": "object",
        "optional": [
            "use_hdf5",
            "material",
            "body_ids",
            "contact_forces",
            "friction_forces",
            "velocity",
            "acceleration",
            "scalar_values",
            "tensor_values",
            "discretization_order",
            "nodes",
            "forces"
        ],
        "doc": "Optional fields in the output"
    },
    {
        "pointer": "/output/paraview/options/use_hdf5",
        "default": false,
        "type": "bool",
        "doc": "If true, export the data as hdf5, compatible with paraview >5.11"
    },
    {
        "pointer": "/output/paraview/options/material",
        "default": false,
        "type": "bool",
        "doc": "If true, write out material values sampled on the vertices of the mesh"
    },
    {
        "pointer": "/output/paraview/options/body_ids",
        "default": false,
        "type": "bool",
        "doc": "Export volumes ids"
    },
    {
        "pointer": "/output/paraview/options/contact_forces",
        "default": false,
        "type": "bool",
        "doc": "If true, write out contact forces for surface"
    },
    {
        "pointer": "/output/paraview/options/friction_forces",
        "default": false,
        "type": "bool",
        "doc": "If true, write out friction forces for surface"
    },
    {
        "pointer": "/output/paraview/options/velocity",
        "default": false,
        "type": "bool",
        "doc": "If true, write out velocities"
    },
    {
        "pointer": "/output/paraview/options/acceleration",
        "default": false,
        "type": "bool",
        "doc": "If true, write out accelerations"
    },
    {
        "pointer": "/output/paraview/options/scalar_values",
        "default": true,
        "type": "bool",
        "doc": "If true, write out scalar values"
    },
    {
        "pointer": "/output/paraview/options/tensor_values",
        "default": true,
        "type": "bool",
        "doc": "If true, write out tensor values"
    },
    {
        "pointer": "/output/paraview/options/discretization_order",
        "default": true,
        "type": "bool",
        "doc": "If true, write out discretization order"
    },
    {
        "pointer": "/output/paraview/options/nodes",
        "default": true,
        "type": "bool",
        "doc": "If true, write out node order"
    },
    {
        "pointer": "/output/paraview/options/forces",
        "default": false,
        "type": "bool",
        "doc": "If true, write out all variational forces on the FE mesh "
    },
    {
        "pointer": "/output/data",
        "default": null,
        "type": "object",
        "optional": [
            "solution",
            "full_mat",
            "stiffness_mat",
            "stress_mat",
            "state",
            "rest_mesh",
            "mises",
            "nodes",
            "advanced"
        ],
        "doc": "File names to write output data to."
    },
    {
        "pointer": "/output/data/solution",
        "default": "",
        "type": "string",
        "doc": "Main variable solution. Unrolled [xyz, xyz, ...] using PolyFEM ordering. If reorder_nodes exports the solution with the same order the vertices of the input mesh as a #n x d file"
    },
    {
        "pointer": "/output/data/full_mat",
        "default": "",
        "type": "string",
        "doc": "System matrix without boundary conditions. Doesn't work for nonlinear problems"
    },
    {
        "pointer": "/output/data/stiffness_mat",
        "default": "",
        "type": "string",
        "doc": "System matrix with boundary conditions. Doesn't work for nonlinear problems"
    },
    {
        "pointer": "/output/data/stress_mat",
        "default": "",
        "type": "string",
        "doc": "Exports stress"
    },
    {
        "pointer": "/output/data/state",
        "default": "",
        "type": "string",
        "doc": "Writes the complete state in PolyFEM hdf5 format, used to restart the sim"
    },
    {
        "pointer": "/output/data/rest_mesh",
        "default": "",
        "type": "string",
        "doc": "Writes the rest mesh in MSH format, used to restart the sim"
    },
    {
        "pointer": "/output/data/mises",
        "default": "",
        "type": "string",
        "doc": "File name to write per-node Von Mises stress values to."
    },
    {
        "pointer": "/output/data/nodes",
        "default": "",
        "type": "string",
        "doc": "Writes the FEM nodes"
    },
    {
        "pointer": "/output/data/advanced",
        "default": null,
        "type": "object",
        "optional": [
            "reorder_nodes"
        ],
        "doc": "advanced options"
    },
    {
        "pointer": "/output/data/advanced/reorder_nodes",
        "default": false,
        "type": "bool",
        "doc": "Reorder nodes accodring to input"
    },
    {
        "pointer": "/output/reference",
        "default": null,
        "optional": [
            "solution",
            "gradient"
        ],
        "type": "object",
        "doc": "Write out the analytic/numerical ground-truth solution and or its gradient"
    },
    {
        "pointer": "/output/reference/solution",
        "default": [],
        "type": "list",
        "doc": "reference solution used to compute errors"
    },
    {
        "pointer": "/output/reference/solution/*",
        "default": "",
        "type": "string",
        "doc": "value as a function of $x,y,z,t$"
    },
    {
        "pointer": "/output/reference/gradient",
        "default": [],
        "type": "list",
        "doc": "gradient of the reference solution to compute errors"
    },
    {
        "pointer": "/output/reference/gradient/*",
        "default": "",
        "type": "string",
        "doc": "value as a function of $x,y,z,t$"
    },
    {
        "pointer": "/output/advanced",
        "default": null,
        "type": "object",
        "optional": [
            "timestep_prefix",
            "sol_on_grid",
            "compute_error",
            "sol_at_node",
            "vis_boundary_only",
            "curved_mesh_size",
            "save_solve_sequence_debug",
            "save_ccd_debug_meshes",
            "save_time_sequence",
            "save_nl_solve_sequence",
            "spectrum"
        ],
        "doc": "Additional output options"
    },
    {
        "pointer": "/output/advanced/timestep_prefix",
        "default": "step_",
        "type": "string",
        "doc": "Prefix for output file names for each time step, the final file is step_i.[vtu|vtm] where i is the time index."
    },
    {
        "pointer": "/output/advanced/sol_on_grid",
        "default": -1,
        "type": "float",
        "doc": "exports the solution sampled on a grid, specify the grid spacing"
    },
    {
        "pointer": "/output/advanced/compute_error",
        "default": true,
        "type": "bool",
        "doc": "Enables the computation of the error. If no reference solution is provided, return the norms of the solution"
    },
    {
        "pointer": "/output/advanced/sol_at_node",
        "default": -1,
        "type": "int",
        "doc": "Write out solution values at a specific node. the values will be written in the output JSON file"
    },
    {
        "pointer": "/output/advanced/vis_boundary_only",
        "default": false,
        "type": "bool",
        "doc": "saves only elements touching the boundaries"
    },
    {
        "pointer": "/output/advanced/curved_mesh_size",
        "default": false,
        "type": "bool",
        "doc": "upsample curved edges to compute mesh size"
    },
    {
        "pointer": "/output/advanced/save_solve_sequence_debug",
        "default": false,
        "type": "bool",
        "doc": "saves AL internal steps, for debugging"
    },
    {
        "pointer": "/output/advanced/save_ccd_debug_meshes",
        "default": false,
        "type": "bool",
        "doc": "saves AL internal steps, for debugging"
    },
    {
        "pointer": "/output/advanced/save_time_sequence",
        "default": true,
        "type": "bool",
        "doc": "saves timesteps"
    },
    {
        "pointer": "/output/advanced/save_nl_solve_sequence",
        "default": false,
        "type": "bool",
        "doc": "saves obj after every nonlinear iteration, for debugging"
    },
    {
        "pointer": "/output/advanced/spectrum",
        "default": false,
        "type": "bool",
        "doc": "exports the spectrum of the matrix in the output JSON. Works only if POLYSOLVE_WITH_SPECTRA is enabled"
    },
    {
        "pointer": "/input",
        "default": null,
        "type": "object",
        "optional": [
            "data"
        ],
        "doc": "input data"
    }
]
